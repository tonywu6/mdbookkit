---
source: crates/rustdoc-link/tests/lib.rs
expression: report
---
  info: successfully resolved all links
     ╭─[supported-syntax:34:10]
  33 │ >
  34 │ > Module [`alloc`][std::alloc] — Memory allocation APIs.
     ·          ──────────┬──────────
     ·                    ╰── https://doc.rust-lang.org/stable/std/alloc/index.html
  35 │ >
  36 │ > ```md
  37 │ > Every [`Option`] is either [`Some`][Option::Some][^1] and contains a value, or
  38 │ > [`None`][Option::None][^1], and does not.
  39 │ > ```
  40 │ >
  41 │ > Every [`Option`] is either [`Some`][Option::Some][^1] and contains a value, or
     ·         ─────┬────           ───────────┬──────────
     ·              │                          ╰── https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.Some
     ·              ╰── https://doc.rust-lang.org/stable/core/option/enum.Option.html
  42 │ > [`None`][Option::None][^1], and does not.
     ·   ───────────┬──────────
     ·              ╰── https://doc.rust-lang.org/stable/core/option/enum.Option.html#variant.None
  43 │ >
  44 │ > ```md
  45 │ > [`Ipv4Addr::LOCALHOST`][core::net::Ipv4Addr::LOCALHOST] — An IPv4 address with the
  46 │ > address pointing to localhost: `127.0.0.1`.
  47 │ > ```
  48 │ >
  49 │ > [`Ipv4Addr::LOCALHOST`][core::net::Ipv4Addr::LOCALHOST] — An IPv4 address with the
     ·   ───────────────────────────┬───────────────────────────
     ·                              ╰── https://doc.rust-lang.org/stable/core/net/ip_addr/struct.Ipv4Addr.html#associatedconstant.LOCALHOST
  50 │ > address pointing to localhost: `127.0.0.1`.
  51 │ 
  52 │ ## Generic parameters
  53 │ 
  54 │ Types can contain generic parameters. This is _compatible_ with rustdoc.
  55 │ 
  56 │ > ```md
  57 │ > [`Vec<T>`] — A heap-allocated _vector_ that is resizable at runtime.
  58 │ > ```
  59 │ >
  60 │ > [`Vec<T>`] — A heap-allocated _vector_ that is resizable at runtime.
     ·   ─────┬────
     ·        ╰── https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html
  61 │ >
  62 │ > ```md
  63 │ > | Phantom type                                       | variance of `T`   |
  64 │ > | :------------------------------------------------- | :---------------- |
  65 │ > | [`&'a mut T`][std::marker::PhantomData<&'a mut T>] | **inv**ariant     |
  66 │ > | [`fn(T)`][std::marker::PhantomData<fn(T)>]         | **contra**variant |
  67 │ > ```
  68 │ >
  69 │ > | Phantom type                                       | variance of `T`   |
  70 │ > | :------------------------------------------------- | :---------------- |
  71 │ > | [`&'a mut T`][std::marker::PhantomData<&'a mut T>] | **inv**ariant     |
     ·     ─────────────────────────┬────────────────────────
     ·                              ╰── https://doc.rust-lang.org/stable/core/marker/struct.PhantomData.html
  72 │ > | [`fn(T)`][std::marker::PhantomData<fn(T)>]         | **contra**variant |
     ·     ─────────────────────┬────────────────────
     ·                          ╰── https://doc.rust-lang.org/stable/core/marker/struct.PhantomData.html
  73 │ 
  74 │ This includes if you use turbofish:
  75 │ 
  76 │ > ```md
  77 │ > `collect()` is one of the few times you’ll see the syntax affectionately known as the
  78 │ > "turbofish", for example: [`Iterator::collect::<Vec<i32>>()`].
  79 │ > ```
  80 │ >
  81 │ > `collect()` is one of the few times you’ll see the syntax affectionately known as the
  82 │ > "turbofish", for example: [`Iterator::collect::<Vec<i32>>()`].
     ·                             ─────────────────┬─────────────────
     ·                                              ╰── https://doc.rust-lang.org/stable/core/iter/traits/iterator/trait.Iterator.html#method.collect
  83 │ 
  84 │ ## Functions and macros
  85 │ 
  86 │ To indicate that an item is a function, add `()` after the function name. To indicate
  87 │ that an item is a macro, add `!` after the macro name, optionally followed by `()`,
  88 │ `[]`, or `{}`. This is _compatible_ with rustdoc.
  89 │ 
  90 │ Note that there cannot be arguments within `()`, `[]`, or `{}`.
  91 │ 
  92 │ > ```md
  93 │ > [`vec!`][std::vec!][^2] is different from [`vec`][std::vec], and don't accidentally
  94 │ > use [`format()`][std::fmt::format()] in place of [`format!()`][std::format!()][^2]!
  95 │ > ```
  96 │ >
  97 │ > [`vec!`][std::vec!][^2] is different from [`vec`][std::vec], and don't accidentally
     ·   ─────────┬─────────                       ────────┬────────
     ·            │                                        ╰── https://doc.rust-lang.org/stable/alloc/vec/index.html
     ·            ╰── https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html
  98 │ > use [`format()`][std::fmt::format()] in place of [`format!()`][std::format!()][^2]!
     ·       ────────────────┬───────────────             ──────────────┬──────────────
     ·                       │                                          ╰── https://doc.rust-lang.org/stable/alloc/macros/macro.format.html
     ·                       ╰── https://doc.rust-lang.org/stable/alloc/fmt/fn.format.html
  99 │ 
 100 │ The macro syntax works for attribute and derive macros as well (even though this is not
 101 │ how they are invoked).
 102 │ 
 103 │ > ```md
 104 │ > There is a [derive macro][serde::Serialize!] to generate implementations of the
 105 │ > [`Serialize`][serde::Serialize] trait.
 106 │ > ```
 107 │ >
 108 │ > There is a [derive macro][serde::Serialize!] to generate implementations of the
     ·              ────────────────┬────────────────
     ·                              ╰── https://docs.rs/serde_derive/1.0.219/serde_derive/derive.Serialize.html
 109 │ > [`Serialize`][serde::Serialize] trait.
     ·   ───────────────┬───────────────
     ·                  ╰── https://docs.rs/serde/1.0.219/serde/ser/trait.Serialize.html
 110 │ 
 111 │ ## Implementors and fully qualified syntax
 112 │ 
 113 │ Trait implementors may supply additional documentation about their implementations. To
 114 │ link to implemented items instead of the traits themselves, use fully qualified paths,
 115 │ including `<... as Trait>` if necessary. This is a _new feature_ that rustdoc does not
 116 │ currently support.
 117 │ 
 118 │ > ```md
 119 │ > [`Result<T, E>`] implements [`IntoIterator`]; its
 120 │ > [**`into_iter()`**][Result::<(), ()>::into_iter] returns an iterator that yields one
 121 │ > value if the result is [`Result::Ok`], otherwise none.
 122 │ >
 123 │ > [`Vec<T>`] also implements [`IntoIterator`]; a vector cannot be used after you call
 124 │ > [**`into_iter()`**][<Vec<()> as IntoIterator>::into_iter].
 125 │ > ```
 126 │ >
 127 │ > [`Result<T, E>`] implements [`IntoIterator`]; its
     ·   ────────┬───────            ────────┬───────
     ·           │                           ╰── https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.IntoIterator.html
     ·           ╰── https://doc.rust-lang.org/stable/core/result/enum.Result.html
 128 │ > [**`into_iter()`**][Result::<(), ()>::into_iter] returns an iterator that yields one
     ·   ────────────────────────┬───────────────────────
     ·                           ╰── https://doc.rust-lang.org/stable/core/result/enum.Result.html#method.into_iter
 129 │ > value if the result is [`Result::Ok`], otherwise none.
     ·                          ───────┬──────
     ·                                 ╰── https://doc.rust-lang.org/stable/core/result/enum.Result.html#variant.Ok
 130 │ >
 131 │ > [`Vec<T>`] also implements [`IntoIterator`]; a vector cannot be used after you call
     ·   ─────┬────                 ────────┬───────
     ·        │                             ╰── https://doc.rust-lang.org/stable/core/iter/traits/collect/trait.IntoIterator.html
     ·        ╰── https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html
 132 │ > [**`into_iter()`**][<Vec<()> as IntoIterator>::into_iter].
     ·   ────────────────────────────┬────────────────────────────
     ·                               ╰── https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.into_iter
 133 │ 
 134 │ > [!NOTE]
 135 │ >
 136 │ > If your type has generic parameters, you must supply concrete types for them for
 137 │ > rust-analyzer to be able to locate an implementation. That is, `Result<T, E>` won't
 138 │ > work, but `Result<(), ()>` will (unless there happen to be types `T` and `E` literally
 139 │ > in scope).
 140 │ 
 141 │ ## Disambiguators
 142 │ 
 143 │ rustdoc's [disambiguator syntax][disambiguator] `prefix@name` is **accepted but
 144 │ ignored**:
 145 │ 
 146 │ > ```md
 147 │ > [`std::vec`], [`mod@std::vec`], and [`macro@std::vec`] all link to the `vec` _module_.
 148 │ > ```
 149 │ >
 150 │ > [`std::vec`], [`mod@std::vec`], and [`macro@std::vec`] all link to the `vec` >
     ·   ──────┬─────  ────────┬───────      ─────────┬────────
     ·         │               │                      ╰── https://doc.rust-lang.org/stable/alloc/vec/index.html
     ·         │               ╰── https://doc.rust-lang.org/stable/alloc/vec/index.html
     ·         ╰── https://doc.rust-lang.org/stable/alloc/vec/index.html
 151 │ > _module_.
 152 │ 
 153 │ Currently, duplicate names in Rust are allowed only if they correspond to items in
 154 │ different [namespaces], for example, between macros and modules, and between struct
 155 │ fields and methods — this is mostly covered by the function and macro syntax, described
 156 │ [above](#functions-and-macros).
 157 │ 
 158 │ If you encounter items that must be disambiguated using rustdoc's disambiguator syntax,
 159 │ other than [the "special types" listed below](#special-types), please [file an
 160 │ issue][issues]!
 161 │ 
 162 │ ## Special types
 163 │ 
 164 │ > [!WARNING]
 165 │ 
 166 │ There is **very limited support** on linking to many [built-in types][rust-types].
 167 │ 
 168 │ **Primitive types**:
 169 │ 
 170 │ Links to named primitive types _are_ resolved:
 171 │ 
 172 │ > ```md
 173 │ > [`bool`], [`u8`], [`str`], and [`char`]
 174 │ > ```
 175 │ >
 176 │ > [`bool`], [`u8`], [`str`], and [`char`].
     ·   ────┬───  ───┬──  ───┬───      ────┬───
     ·       │        │       │             ╰── https://doc.rust-lang.org/nightly/core/primitive.char.html
     ·       │        │       ╰── https://doc.rust-lang.org/nightly/core/primitive.str.html
     ·       │        ╰── https://doc.rust-lang.org/nightly/core/primitive.u8.html
     ·       ╰── https://doc.rust-lang.org/nightly/core/primitive.bool.html
 177 │ 
     ╰────
     ╭─[supported-syntax:212:3]
 211 │ >
 212 │ > [The Option type](std::option::Option)
     ·   ───────────────────┬──────────────────
     ·                      ╰── https://doc.rust-lang.org/stable/core/option/enum.Option.html
 213 │ 
 214 │ Linking with reusable references:
 215 │ 
 216 │ > ```md
 217 │ > [The Option type][option-type]
 218 │ >
 219 │ > [option-type]: std::option::Option
 220 │ > ```
 221 │ >
 222 │ > [The Option type][option-type]
     ·   ───────────────┬──────────────
     ·                  ╰── https://doc.rust-lang.org/stable/core/option/enum.Option.html
 223 │ >
 224 │ > [option-type]: std::option::Option
 225 │ 
 226 │ Reference-style links `[text][id]` without a corresponding `[id]: name` part will be
 227 │ treated the same as inline-style links `[text](id)`:
 228 │ 
 229 │ > ```md
 230 │ > [The Option type][std::option::Option]
 231 │ > ```
 232 │ >
 233 │ > [The Option type][std::option::Option]
     ·   ───────────────────┬──────────────────
     ·                      ╰── https://doc.rust-lang.org/stable/core/option/enum.Option.html
 234 │ 
 235 │ Shortcuts are supported, and can contain inline markups:
 236 │ 
 237 │ > ```md
 238 │ > You can create a [`Vec`] with [**`Vec::new`**], or by using the [_`vec!`_][^2] macro.
 239 │ > ```
 240 │ >
 241 │ > You can create a [`Vec`] with [**`Vec::new`**], or by using the [_`vec!`_][^2] macro.
     ·                    ───┬───      ────────┬───────                  ─────┬────
     ·                       │                 │                              ╰── https://doc.rust-lang.org/stable/alloc/macros/macro.vec.html
     ·                       │                 ╰── https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html#method.new
     ·                       ╰── https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html
 242 │ 
 243 │ (The items must still be resolvable; in this case `Vec` and `vec!` come from the
 244 │ prelude.)
 245 │ 
 246 │ ## Linking to page sections
 247 │ 
 248 │ To link to a known section on a page, use a URL fragment, just like a normal link. This
 249 │ is _compatible_ with rustdoc.
 250 │ 
 251 │ <!-- prettier-ignore-start -->
 252 │ 
 253 │ > ```md
 254 │ > [When Should You Use Which Collection?][std::collections#when-should-you-use-which-collection]
 255 │ > ```
 256 │ >
 257 │ > [When Should You Use Which Collection?][std::collections#when-should-you-use-which-collection]
     ·   ───────────────────────────────────────────────┬──────────────────────────────────────────────
     ·                                                  ╰── https://doc.rust-lang.org/stable/std/collections/index.html
 258 │ 
 259 │ <!-- prettier-ignore-end -->
 260 │ 
 261 │ ---
 262 │ 
 263 │ [^1]:
 264 │     rust-analyzer's ability to generate links for enum variants like `Option::Some` was
 265 │     improved only somewhat recently: before
 266 │     [#19246](https://github.com/rust-lang/rust-analyzer/pull/19246), links for variants
 267 │     and associated items may only point to the types themselves. If linking to such
 268 │     items doesn't seem to work for you, be sure to upgrade to a newer rust-analyzer
 269 │     first!
 270 │ 
 271 │ [^2]:
 272 │     As of rust-analyzer <ra-version>(version)</ra-version>, links generated for
 273 │     re-exported items don't always work. This happens often with macros. Examples
 274 │     include [`std::format!`] (seen above) and [`tokio::main!`]. For more info, see
     ·             ────────┬───────                  ────────┬───────
     ·                     │                                 ╰── https://docs.rs/tokio-macros/2.5.0/tokio_macros/macro.main.html
     ·                     ╰── https://doc.rust-lang.org/stable/alloc/macros/macro.format.html
 275 │     [Caveats](caveats.md#re-exported-items).
     ╰────
