use anyhow::{Result, anyhow};
use serde::Deserialize;
use tap::Pipe;

pub fn is_ci() -> Option<String> {
    let ci = std::env::var("CI").unwrap_or("".into());
    if matches!(ci.as_str(), "" | "0" | "false") {
        None
    } else {
        Some(ci)
    }
}

/// Flag indicating how the program should proceed when there are warnings.
///
/// Used in preprocessor options.
///
/// Doc comments for variants in this enum will show up in autogenerated docs.
#[derive(clap::ValueEnum, Deserialize, Debug, Default, Clone, Copy)]
#[serde(rename_all = "lowercase")]
pub enum OnWarning {
    /// Fail if the environment variable `CI` is set to a value other than `0` or `false`.
    /// Environments like GitHub Actions configure this automatically.
    #[default]
    #[serde(rename = "ci")]
    #[clap(name = "ci")]
    FailInCi,

    /// Fail as long as there are warnings, even in local use.
    AlwaysFail,
}

impl OnWarning {
    pub fn check(&self, level: log::Level) -> Result<()> {
        match level {
            log::Level::Error => Err(anyhow!("preprocessor has errors")),
            log::Level::Warn => match self {
                Self::AlwaysFail => {
                    anyhow!("treating warnings as errors because the `fail-on-warnings` option is set to \"always\"")
                        .context("preprocessor has errors")
                        .pipe(Err)
                }
                Self::FailInCi => {
                    let Some(ci) = Self::warning_as_error() else {
                        return Ok(());
                    };
                    anyhow!("treating warnings as errors because the `fail-on-warnings` option is set to \"ci\" and CI={ci}")
                        .context("preprocessor has errors")
                        .pipe(Err)
                }
            },
            _ => Ok(()),
        }
    }

    pub fn adjusted<T, E>(&self, result: Result<Result<T, E>, E>) -> Result<Result<T, E>, E> {
        match result {
            Ok(Err(error)) if Self::warning_as_error().is_some() => Err(error),
            result => result,
        }
    }

    fn warning_as_error() -> Option<String> {
        is_ci()
    }
}
